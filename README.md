## はじめに

あなたは関数型言語を始めたばかりです。
「純粋な関数」という概念を理解するのにそれほど時間はかからないでしょう。
関数型言語を学んでいくと、関数型言語プログラマーがそのパラダイムに夢中になっていることに気が付くでしょう。
「純粋な関数はコード内を見なくても推論ができる」、「純粋な関数は戦争を起こしにくい」、「純粋な関数は参照透過性がある」など。
純粋な関数が素晴らしいのは間違いありません。
間違いありませんが、問題もあるのです...

純粋な関数とは、副作用のない関数のことです。
しかしプログラミングをやったことがある人ならば、副作用はプログラミングの目的のすべてだということを知っているでしょう。
誰も見ていないところで円周率の計算を100回やることに何の意味があるのでしょうか。
データベースにデータを保存できないなら、データベースの存在意義とは何でしょうか。
私たちは実在のデバイスからデータを読んだり、ネットワークにリクエストを送ったりする **必要があります**。
副作用なしでこれらのことを実現するのは不可能です。
それでも、関数型言語は純粋な関数で構成されます。
関数型言語プログラマーはこの問題をどのように解決するのでしょう。

簡単に言うと、数学者と同じことをします。騙すのです。
騙す、と言った時に実際にはルールには従います。
ですが、ルールの抜け道を見つけ、それを広げて象の群れを扱えるようにするのです。
騙す方法はニつあります。

1. Dependency Injectionを使う: 柵の向こう側に問題を切り分ける
2. Effect Functorを使う: 思いっきり遅延させる

## Dependency Injection

Dependency Injectionは副作用を扱う一つ目の方法です。
この方法では、関数の純粋でない部分を抜き出して、関数の引数に突っ込んでしまいます。
そして副作用を行うかどうかは他の関数の責任だ、と匙を投げるのです。
コードを見てみましょう。

```js
// logSomething :: String -> String
function logSomething(something) {
    const dt = (new Date()).toIsoString();
    console.log(`${dt}: ${something}`);
    return something;
}
```

この`logSomething()`関数には二つの純粋でない部分があります。
Dateオブジェクトを使うことと、コンソールに書き出すことです。
この関数は副作用を引き起こすだけでなく、毎ミリ秒ごとに違った結果を返すのです。
どうやってこの関数を純粋な関数にするのでしょうか。
純粋でない部分を抜き出して、関数の引数に突っ込みましょう。

```js
// logSomething: Date -> Console -> String -> *
function logSomething(d, cnsl, something) {
    const dt = d.toIsoString();
    return cnsl.log(`${dt}: ${something}`);
}
```

これを使うときは、自分で明示的に純粋ではないパーツを引数として渡す必要があります。


```js
const something = "Curiouser and curiouser!"
const d = new Date();
logSomething(d, console, something);
// ⦘ Curiouser and curiouser!
```

「一つ上のレイヤーに問題を棚上げしているだけで、前と同じだ。純粋じゃあない。」とあなたは思うかもしれません。
それは正しい考え方です。Dependency Injection はルールの抜け道です。知らない振りをしているだけなのです。
「ああ、すいません。`cnsl`オブジェクトの`log()`がIOを発生させるかどうかは知らないのです。誰かがそれをくれたのです。どこから来たのかも分かりません。」
これは少し怠惰のようにも思えます。

でも見かけよりも馬鹿なことではないのです。
`logSomething()`関数を見てみましょう。
もしこの関数を純粋ではない関数にしたいなら、あなたが関数の引数を使ってそれを設定しないといけないのです。
純粋な引数を渡せば、簡単に純粋な関数にすることができます。

```js
const d = {toISOString: () => '1865-11-26T16:00:00.000Z'};
const cnsl = {
    log: () => {
        // do nothing
    },
};
logSomething(d, cnsl, "Off with their heads!");
//  ￩ "Off with their heads!"
```

今この関数は(`undefined を返す以外`)何もしません。
しかし、この関数は完全に純粋です。
同じ引数で呼び出せば、毎回同じ結果を返します。
このことはとても重要です。
純粋ではない関数にするためには恣意的な行動が求められます。
言い換えるなら、関数が依存しているものはすべて引数にあるのです。
`Date`や`console`といったグローバルなものには依存しません。

また重要なことは、以前の純粋でない関数にも関数を渡すことが可能です。
違う例を見てみましょう。
フォームにユーザー名を入力することを想像してください。
私たちはこのユーザー名を取得したいものだと仮定します。

```js
// getUserNameFromDOM :: () -> String
function getUserNameFromDOM() {
    return document.querySelector('#username').value;
}

const username = getUserNameFromDOM();
username;
// ￩ "mhatter"
```
